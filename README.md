# Networking

This package helps your app talk to any remote HTTP server.  You can achieve this with very little client code, thanks to the power of Swift protocols and the Combine framework.

Your client must define types that adopt the `Requestable` protocol.  Adopters of the `Requestable` protocol know how to provide all the data needed to invoke an HTTP endpoint, such as the URL, headers, body, query, and more.  A different object is responsible for actually constructing and running concrete network requests; that object will obtain the needed values from a `Requestable` adopter instance.  Any data that won't be known until runtime should be given as constructor arguments to your `Requestable` adopter instances.  Each adopter of `Requestable` must also specify associated types called `Input` and `Response`.  You may use the provided types, `EmptyInput` and `EmptyResponse`, to indicate that one or both of these are blank from the client's point of view.  `EmptyInput` is an alias of `Void`, and `EmptyResponse` is an empty struct that adopts `Decodable`.

When you are ready to send a network request, you must obtain an instance of an adopter of the `Networking` protocol.  This object will actually perform the network request.  An implementation called `RealNetworkProvider` is available out of the box.  It builds a genuine `URLRequest` object, sends the request through the native URL loading system, and reports the real outcome to your client.

The `Networking` protocol has a method called `.sendRequest(for:)`, which accepts a `Requestable` adopter instance.  This method returns a Combine `Publisher` that must send a value event when the request succeeds, or a failure event of type `NetworkError` when the request fails.  The `RealNetworkProvider` implementation of `.sendRequest(for:)` uses the system-native `URLSession.dataTaskPublisher(for:)` pattern, and wraps the publisher's error response (if any) in an appropriate `NetworkError` enum case.

If you want to mock an endpoint invocation for frontend development and testing, you can use the `Mockable` protocol and `MockNetworkProvider` class.  The `Mockable` protocol inherits from `Endpoint`; it adds a single property called `mockResponse`, which simply returns an instance of the endpoint's `Response` type.  `MockNetworkProvider` is an alternative `Networking` implementation that simply provides the `mockResponse` from any given `Mockable` endpoint object after a configurable delay (via the `simulatedDelay` instance property), which defaults to 1.5 seconds.  If given an endpoint that does not conform to `Mockable`, then `MockNetworkProvider` will simulate a failed network call by reporting the error `.noMockAvailable` through the returned publisher, still applying the delay.  Otherwise, you can force `MockNetworkProvider` to simulate a failure response of any kind by setting the `simulatedError` instance property.  If set to a non-nil value, the `simulatedError` property will always cause the returned publisher to yield a `.failure` event wrapping the specified error after the specified delay.  The default value of this property is `nil`, which is required for the returned publisher to yield a `.success` event.

`RealNetworkProvider` and `MockNetworkProvider` both provide singleton instances for your convenience.

When you want to bind your UI to the invocation of an endpoint, create an instance of `ServiceForEndpoint`.  `ServiceForEndpoint` is a small, generic wrapper class that saves you from writing much boilerplate code.  It knows how to call an endpoint through whatever `Networking` adopter you provide, via a method called `contactEndpoint(with:)`; how to map the success response to any output type you like, using a routine you specify in the constructor; and how to publish the results on the main thread using the `ObservableObject` idiom.  It also helpfully reframes the publisher as a never-failing entity that reports all events through a generic enum called `LoadingState`.  The `LoadingState` enum has four cases: `.notStarted`, `.loading`, `.success(Output)`, and `.failure(Error)`.  This range of cases allows the publisher to emit value events to report on the whole lifecycle of the URL request, including cases where the request fails, without requiring the publisher itself to fail, and without requiring clients to infer meaning (such as "not started" or "loading") from the publisher's silence.  As a result, you can generate UI declaratively in response to the currently observed `LoadingState` value provided by your `ServiceForEndpoint` environment object.  When you invoke `contactEndpoint(with:)`, the `ServiceForEndpoint` instance immediately sends a `.loading` value on the returned publisher, and then eventually uses the publisher to send an instance of your adopter's `Response` type if the request succeeds or a `NetworkError` if the request fails.  The client may re-invoke `contactEndpoint(with:)` in order to retry the action.

You may want to create an additional shim between your UI and your `ServiceForEndpoint` instance, in order to decouple the UI from the `Endpoint` type parameter of `ServiceForEndpoint`.  This package provides a class called `ServiceProvider` for exactly that purpose.  `ServiceProvider` is a small, generic class that adopts `ObservableObject`, publishes a `LoadingState` value, accepts a `NetworkProvider` injection, and requires you to override a method called `attemptLoad(with:)`.  Your presentational UI layer can consume a `ServiceProvider` instance as an `@EnvironmentObject`, and may even invoke its `attemptLoad(with:)` routine, without knowing anything about the upstream data source or the real effects of `attemptLoad(with:)`.  You can write a small subclass of `ServiceProvider` to encapsulate details of how the `Endpoint` and `NetworkProvider` layers are used, thus separating the UI from these concerns.
